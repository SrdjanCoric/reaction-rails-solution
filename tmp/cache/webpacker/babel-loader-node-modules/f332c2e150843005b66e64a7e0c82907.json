{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport * as types from \"../constants/ActionTypes\";\n\nvar cards = function cards() {\n  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var action = arguments.length > 1 ? arguments[1] : undefined;\n\n  switch (action.type) {\n    case types.FETCH_BOARD_SUCCESS:\n      var lists = action.board.lists;\n      var boardId = action.board.id;\n      var _cards = [];\n      lists.forEach(function (list) {\n        return _cards = _cards.concat(list.cards);\n      });\n      var filteredState = state.filter(function (card) {\n        return card.board_id !== boardId;\n      });\n      _cards = _cards.map(function (card) {\n        var existingVersion = state.find(function (stateCard) {\n          return card.id === stateCard.id;\n        });\n\n        if (existingVersion) {\n          return _objectSpread({}, existingVersion, {}, card);\n        } else {\n          return card;\n        }\n      });\n      return filteredState.concat(_cards);\n\n    case types.CREATE_CARD_SUCCESS:\n      return state.concat(action.payload.card);\n\n    case types.FETCH_CARD_SUCCESS:\n      var excludedCards = state.filter(function (card) {\n        return card.id !== action.payload.card.id;\n      });\n      var card = action.payload.card;\n      return excludedCards.concat(card);\n\n    case types.UPDATE_CARD_SUCCESS:\n      return state.map(function (card) {\n        if (card.id === action.payload.card.id) return action.payload.card;else return card;\n      });\n\n    case types.DELETE_CARD_SUCCESS:\n      return state.filter(function (card) {\n        if (card.id !== action.payload.cardId) {\n          return card;\n        }\n\n        return null;\n      });\n\n    default:\n      return state;\n  }\n};\n\nexport default cards;","map":{"version":3,"sources":["/home/srdjan/Desktop/LS/capstone_ta/reaction_solution/app/javascript/reducers/cards.js"],"names":["types","cards","state","action","type","FETCH_BOARD_SUCCESS","lists","board","boardId","id","forEach","list","concat","filteredState","filter","card","board_id","map","existingVersion","find","stateCard","CREATE_CARD_SUCCESS","payload","FETCH_CARD_SUCCESS","excludedCards","UPDATE_CARD_SUCCESS","DELETE_CARD_SUCCESS","cardId"],"mappings":";;;;;;AAAA,OAAO,KAAKA,KAAZ,MAAuB,0BAAvB;;AAEA,IAAMC,KAAK,GAAG,SAARA,KAAQ,GAAwB;AAAA,MAAvBC,KAAuB,uEAAf,EAAe;AAAA,MAAXC,MAAW;;AACpC,UAAQA,MAAM,CAACC,IAAf;AACE,SAAKJ,KAAK,CAACK,mBAAX;AACE,UAAMC,KAAK,GAAGH,MAAM,CAACI,KAAP,CAAaD,KAA3B;AACA,UAAME,OAAO,GAAGL,MAAM,CAACI,KAAP,CAAaE,EAA7B;AACA,UAAIR,MAAK,GAAG,EAAZ;AACAK,MAAAA,KAAK,CAACI,OAAN,CAAc,UAAAC,IAAI;AAAA,eAAKV,MAAK,GAAGA,MAAK,CAACW,MAAN,CAAaD,IAAI,CAACV,KAAlB,CAAb;AAAA,OAAlB;AACA,UAAMY,aAAa,GAAGX,KAAK,CAACY,MAAN,CAAa,UAAAC,IAAI,EAAI;AACzC,eAAOA,IAAI,CAACC,QAAL,KAAkBR,OAAzB;AACD,OAFqB,CAAtB;AAGAP,MAAAA,MAAK,GAAGA,MAAK,CAACgB,GAAN,CAAU,UAAAF,IAAI,EAAI;AACxB,YAAMG,eAAe,GAAGhB,KAAK,CAACiB,IAAN,CACtB,UAAAC,SAAS;AAAA,iBAAIL,IAAI,CAACN,EAAL,KAAYW,SAAS,CAACX,EAA1B;AAAA,SADa,CAAxB;;AAGA,YAAIS,eAAJ,EAAqB;AACnB,mCAAYA,eAAZ,MAAgCH,IAAhC;AACD,SAFD,MAEO;AACL,iBAAOA,IAAP;AACD;AACF,OATO,CAAR;AAUA,aAAOF,aAAa,CAACD,MAAd,CAAqBX,MAArB,CAAP;;AACF,SAAKD,KAAK,CAACqB,mBAAX;AACE,aAAOnB,KAAK,CAACU,MAAN,CAAaT,MAAM,CAACmB,OAAP,CAAeP,IAA5B,CAAP;;AACF,SAAKf,KAAK,CAACuB,kBAAX;AACE,UAAMC,aAAa,GAAGtB,KAAK,CAACY,MAAN,CACpB,UAAAC,IAAI;AAAA,eAAIA,IAAI,CAACN,EAAL,KAAYN,MAAM,CAACmB,OAAP,CAAeP,IAAf,CAAoBN,EAApC;AAAA,OADgB,CAAtB;AAGA,UAAMM,IAAI,GAAGZ,MAAM,CAACmB,OAAP,CAAeP,IAA5B;AACA,aAAOS,aAAa,CAACZ,MAAd,CAAqBG,IAArB,CAAP;;AACF,SAAKf,KAAK,CAACyB,mBAAX;AACE,aAAOvB,KAAK,CAACe,GAAN,CAAU,UAAAF,IAAI,EAAI;AACvB,YAAIA,IAAI,CAACN,EAAL,KAAYN,MAAM,CAACmB,OAAP,CAAeP,IAAf,CAAoBN,EAApC,EAAwC,OAAON,MAAM,CAACmB,OAAP,CAAeP,IAAtB,CAAxC,KACK,OAAOA,IAAP;AACN,OAHM,CAAP;;AAIF,SAAKf,KAAK,CAAC0B,mBAAX;AACE,aAAOxB,KAAK,CAACY,MAAN,CAAa,UAAAC,IAAI,EAAI;AAC1B,YAAIA,IAAI,CAACN,EAAL,KAAYN,MAAM,CAACmB,OAAP,CAAeK,MAA/B,EAAuC;AACrC,iBAAOZ,IAAP;AACD;;AACD,eAAO,IAAP;AACD,OALM,CAAP;;AAMF;AACE,aAAOb,KAAP;AAzCJ;AA2CD,CA5CD;;AA8CA,eAAeD,KAAf","sourcesContent":["import * as types from \"../constants/ActionTypes\";\n\nconst cards = (state = [], action) => {\n  switch (action.type) {\n    case types.FETCH_BOARD_SUCCESS:\n      const lists = action.board.lists;\n      const boardId = action.board.id;\n      let cards = [];\n      lists.forEach(list => (cards = cards.concat(list.cards)));\n      const filteredState = state.filter(card => {\n        return card.board_id !== boardId;\n      });\n      cards = cards.map(card => {\n        const existingVersion = state.find(\n          stateCard => card.id === stateCard.id\n        );\n        if (existingVersion) {\n          return { ...existingVersion, ...card };\n        } else {\n          return card;\n        }\n      });\n      return filteredState.concat(cards);\n    case types.CREATE_CARD_SUCCESS:\n      return state.concat(action.payload.card);\n    case types.FETCH_CARD_SUCCESS:\n      const excludedCards = state.filter(\n        card => card.id !== action.payload.card.id\n      );\n      const card = action.payload.card;\n      return excludedCards.concat(card);\n    case types.UPDATE_CARD_SUCCESS:\n      return state.map(card => {\n        if (card.id === action.payload.card.id) return action.payload.card;\n        else return card;\n      });\n    case types.DELETE_CARD_SUCCESS:\n      return state.filter(card => {\n        if (card.id !== action.payload.cardId) {\n          return card;\n        }\n        return null;\n      });\n    default:\n      return state;\n  }\n};\n\nexport default cards;\n"]},"metadata":{},"sourceType":"module"}